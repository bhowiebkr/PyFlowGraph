# Story 3.3: Native Object Passing System

## Status
Draft

## Story

**As a** user,
**I want** to pass Python objects directly between nodes without any serialization,
**so that** I can work with large tensors and DataFrames at maximum performance.

## Acceptance Criteria

1. Direct Python object references passed between nodes (no copying)
2. Support for all Python types including PyTorch tensors, NumPy arrays, Pandas DataFrames
3. Memory-mapped sharing for objects already in RAM
4. Reference counting system for automatic cleanup
5. No type restrictions or JSON fallbacks ever

## Tasks / Subtasks

- [ ] **Task 1**: Implement comprehensive object reference system (AC: 1)
  - [ ] Subtask 1.1: Enhance pin_values dictionary to handle all Python object types
  - [ ] Subtask 1.2: Remove any remaining JSON serialization fallbacks
  - [ ] Subtask 1.3: Implement direct object reference passing between nodes
  - [ ] Subtask 1.4: Add object type validation and error handling

- [ ] **Task 2**: Add advanced data science framework support (AC: 2)
  - [ ] Subtask 2.1: Add PyTorch tensor support with device management
  - [ ] Subtask 2.2: Add NumPy array support with dtype preservation
  - [ ] Subtask 2.3: Add Pandas DataFrame support with index/column preservation
  - [ ] Subtask 2.4: Add support for complex nested objects and custom classes

- [ ] **Task 3**: Implement memory-mapped sharing system (AC: 3)
  - [ ] Subtask 3.1: Add memory mapping detection for large objects
  - [ ] Subtask 3.2: Implement zero-copy sharing for compatible objects
  - [ ] Subtask 3.3: Add shared memory buffer management
  - [ ] Subtask 3.4: Optimize memory access patterns for large datasets

- [ ] **Task 4**: Create reference counting and cleanup system (AC: 4)
  - [ ] Subtask 4.1: Implement object reference tracking using weakref
  - [ ] Subtask 4.2: Add automatic garbage collection for unreferenced objects
  - [ ] Subtask 4.3: Create memory cleanup policies for long-running sessions
  - [ ] Subtask 4.4: Add GPU memory cleanup for ML framework objects

- [ ] **Task 5**: Eliminate all type restrictions and JSON fallbacks (AC: 5)
  - [ ] Subtask 5.1: Remove any remaining JSON conversion code paths
  - [ ] Subtask 5.2: Add universal object support without type checking
  - [ ] Subtask 5.3: Implement robust error handling for unsupported operations
  - [ ] Subtask 5.4: Add validation to prevent JSON fallback scenarios

- [ ] **Task 6**: Testing and validation (AC: 1-5)
  - [ ] Subtask 6.1: Create unit tests for direct object passing
  - [ ] Subtask 6.2: Create integration tests for ML framework objects
  - [ ] Subtask 6.3: Add memory leak detection tests
  - [ ] Subtask 6.4: Create performance benchmarks comparing copy vs reference passing

## Dev Notes

### Previous Story Insights
Key learnings from Story 3.2 (Single Shared Python Interpreter):
- SingleProcessExecutor successfully replaced subprocess isolation with direct execution
- Pin_values dictionary now stores actual Python objects (foundation for 3.3)
- Direct function calls are working in shared interpreter
- Persistent namespace enables import and variable sharing between executions
- Performance improvements of 100-1000x achieved by eliminating subprocess overhead
- Security model changed from process isolation to direct execution with error handling
- Memory management and reference counting infrastructure needs identified
[Source: docs/stories/3.2.story.md#dev-agent-record]

### Current Object Passing Foundation
The SingleProcessExecutor in Story 3.2 established the basic infrastructure:
- **Object Store**: `self.object_store: Dict[Any, Any] = {}` for direct object storage
- **Direct References**: Pin values store actual Python objects, not JSON strings
- **Namespace Persistence**: All imports and variables remain loaded between executions
- **No Serialization**: JSON serialization/deserialization completely removed
- **Performance**: Direct object references eliminate copy overhead
[Source: src/execution/single_process_executor.py lines 37-38, 167-178]

### Technical Implementation Details

#### Current Architecture Integration Points
- **GraphExecutor**: `src/execution/graph_executor.py` - Main execution orchestrator using SingleProcessExecutor
- **SingleProcessExecutor**: `src/execution/single_process_executor.py` - Direct function call execution with object storage
- **Pin Values**: Dictionary mapping Pin objects to actual Python objects (no JSON)
- **Object Store**: Direct object reference storage in SingleProcessExecutor
- **Memory Management**: Basic cleanup with gc.collect() and GPU cache clearing
[Source: src/execution/graph_executor.py lines 47-48, src/execution/single_process_executor.py lines 160-229]

#### File Locations & Structure
- **Main Enhancement Target**: `src/execution/single_process_executor.py` - Enhance object reference and memory management
- **GraphExecutor Updates**: `src/execution/graph_executor.py` - Update pin_values handling for enhanced object passing
- **New Testing**: `tests/test_object_passing.py` (new) - Comprehensive object reference testing
- **Integration Testing**: Extend `tests/test_execution_engine.py` for advanced object types
[Source: docs/architecture/source-tree.md#execution-system]

#### Data Types and Framework Support
- **Basic Types**: All Python built-in types (int, float, str, list, dict, set, tuple)
- **NumPy Support**: Arrays with dtype, shape, and memory layout preservation
- **PyTorch Support**: Tensors with device (CPU/GPU), dtype, and gradient tracking
- **Pandas Support**: DataFrames, Series with indexes, dtypes, and metadata
- **Custom Objects**: User-defined classes, nested structures, complex hierarchies
- **Memory Objects**: Memory-mapped files, shared arrays, zero-copy buffers
[Source: docs/prd.md#story-33-native-object-passing-system, src/execution/single_process_executor.py lines 66-74]

#### Memory Management Architecture
- **Reference Counting**: WeakValueDictionary for automatic reference cleanup
- **GPU Memory**: PyTorch CUDA cache clearing for GPU memory management
- **Garbage Collection**: Explicit gc.collect() calls for Python object cleanup
- **Memory Mapping**: Zero-copy sharing for large objects already in RAM
- **Cleanup Policies**: Automatic cleanup for long-running sessions
[Source: src/execution/single_process_executor.py lines 44, 180-203]

#### Performance Considerations
- **Zero Copy**: Direct object references eliminate copy overhead completely
- **Memory Sharing**: Objects shared by reference, not duplicated
- **GPU Tensors**: Direct GPU memory sharing without CPU roundtrips
- **Large DataFrames**: Memory-mapped sharing for datasets larger than RAM
- **Cleanup Overhead**: Minimal reference counting with weak references
[Source: docs/prd.md#epic-3-single-process-execution-architecture]

#### Security and Error Handling
- **No Sandboxing**: All code executes in main process (security trade-off from 3.2)
- **Error Isolation**: Comprehensive exception handling prevents main application crashes
- **Memory Safety**: Reference counting prevents memory leaks from unreferenced objects
- **Type Safety**: No type restrictions - support any Python object type
- **Validation**: Robust error handling for edge cases and unsupported operations
[Source: src/execution/single_process_executor.py lines 130-141, docs/stories/3.2.story.md#security-review]

### Testing

#### Testing Requirements
- **Unit Tests**: `tests/test_object_passing.py` - Direct object reference testing
- **Framework Tests**: Test PyTorch tensors, NumPy arrays, Pandas DataFrames
- **Memory Tests**: Reference counting, garbage collection, memory leak detection
- **Performance Tests**: Benchmark object passing performance vs copying
- **Integration Tests**: End-to-end object passing through complex graphs
[Source: docs/architecture/coding-standards.md#testing-standards]

#### Testing Framework and Patterns
- **Framework**: Python unittest (established pattern in project)
- **Test Runner**: Custom PySide6 GUI test runner for interactive testing
- **Timeout**: All tests must complete within 10 seconds maximum
- **No Mocking**: Use real objects for Qt components, avoid Mock with PySide6
- **Test Naming**: Follow `test_{behavior}_when_{condition}` pattern
[Source: docs/architecture/coding-standards.md#pyside6qt-testing-requirements, CLAUDE.md#testing]

#### Specific Testing Requirements for Story 3.3
- Test direct object reference passing between nodes (no copying)
- Test PyTorch tensor passing with device and dtype preservation
- Test NumPy array passing with shape and memory layout preservation  
- Test Pandas DataFrame passing with indexes and metadata preservation
- Test custom object and nested structure passing
- Test memory leak detection with long-running object passing scenarios
- Test reference counting cleanup when objects are no longer referenced
- Test GPU memory management for PyTorch tensors
- Test zero-copy sharing performance improvements
- Test error handling for edge cases and type conflicts

### Technical Constraints
- **Windows Platform**: Use Windows-compatible commands and paths, no Unicode characters
- **PySide6 Framework**: Maintain compatibility with existing Qt-based architecture
- **No JSON Fallbacks**: Eliminate all JSON serialization completely (AC: 5)
- **Memory Safety**: Prevent memory leaks while maintaining performance
- **Backward Compatibility**: Existing graphs must work without modification
[Source: docs/architecture/coding-standards.md#prohibited-practices, CLAUDE.md]

## Change Log

| Date       | Version | Description                 | Author    |
| ---------- | ------- | --------------------------- | --------- |
| 2025-01-20 | 1.0     | Initial story creation based on PRD Epic 3 | Bob (SM) |